# Инфраструктура и архитектура

# Инфраструктура

### СI

**СI** (Continuous Integration) — **непрерывная интеграция**. Это значит, что репозиторий проекта постоянно обновляется. Изменения проверяются автоматически.

Иными словами, как только можно проверить маленький кусочек функциональности, его сразу загружают на тестовый стенд.

**Пример.** Представь: команда разрабатывает корзину для товаров в интернет-магазине.

Разработчик написал код для части функциональности — например, для метода расчёта скидок. Он сделал пул-реквест в `master`-ветку. Тут же запускаются проверки:
сначала юнит-тесты, потом интеграционные и E2E.

Это и есть непрерывная интеграция. Как только что-то изменилось, нужно:

- сразу залить новый кусочек в репозиторий;
- проверить, что новый код не конфликтует со старым.

Другой подход — программа попадёт в общую ветку разработки, только когда разработчик допишет код до конца. Это не CI.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_1.png

### **CD**

**CD** (Continuous Delivery) — **непрерывное развёртывание**. Это значит, что процессы сборки и заливки на стенд — автоматические.

Например, разработчик залил код в ветку и сделал пул-реквест. Тут же запустились тесты — сами, автоматически.

Если тесты не упали, пул-реквест попадает в основную ветку. Она собирается, приложение попадает на стенд.

Без СD всё происходит не автоматически, а по команде разработчика или тестировщика.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_2.png

### Процесс CI/CD

Процесс CI/CD состоит из нескольких этапов:

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_3.png

Представь, что разработчикам нужно сделать новую функциональность для сервиса [Mesto](https://qa-mesto.praktikum-services.ru/): теперь на сайт можно добавлять
видео.

Вот как проходит процесс:

- **Планирование** — менеджер передаёт команде задачу.
- **Разработка** — разработчик создаёт отдельную ветку и пишет в ней код.
- **Сборка** — новая функциональность попадает в основную ветку разработки. Приложение автоматически загружается на тестовый стенд.
- **Тестирование** — запускаются тесты. Они проверяют, что функциональность работает точно так, как описано в документации.
- **Релиз** — если тесты не упали, функциональность попадает в `master`-ветку.
- **Развёртывание** — `master`-ветка собирается на продуктивном стенде.
- **Эксплуатация** — пользователи видят новую функциональность и добавляют видео на сайт.
- **Поддержка и мониторинг** — пользователи дают обратную связь, команда дорабатывает продукт.

Ручные операции в этом процессе заменили командами и скриптами.

Как только проходит последний этап, всё начинается заново — получается цикл.

**Как выглядит цикл разработки без CI/CD.** Разработчик сделал коммит в репозиторий. Автотесты не запускаются сами: тестировщику нужно дать команду.

Разработчикам приходится подключаться к стендам, чтобы залить актуальную версию приложения. Когда много операций совершают вручную, легко что-то упустить —
поэтому появляются ошибки.

### Чем помогает CI/CD

**Обновлять приложение чаще и быстрее**. На стендах практически всегда актуальная версия приложения, потому что изменения сразу проходят тесты и попадают в
основную ветку.

**Оптимизировать поиск багов на всех этапах**. Приложение обновляется маленькими кусочками, поэтому легко найти ошибку.

**Ускорить цикл разработки**. Процессы автоматизированы, поэтому не нужно ждать, пока кто-то запустит автотесты.

### Инструменты CI/CD

Вот какие инструменты помогают на разных этапах:

- Git — объединить код нескольких разработчиков.
- Jenkins — запускать действия автоматически: компиляцию, запуск тестов и сборку проекта.
- Docker — запустить приложение в разных окружениях.
- Kubernetes — оптимизировать работу с докер-контейнерами.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_4.png

### Docker

Docker помогает запускать приложение в разных окружениях.

Представь: автор приложения пишет код и кладёт его в репозиторий. Другой разработчик его клонирует.

Разработчик развернёт проект на своём компьютере — не таком, как у автора проекта. У него другая операционная система и настройки. Например, у автора приложения
Java 8, у другого разработчика — Java 11.

Приложение может не запуститься.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_5.png

Docker позволяет «упаковать» приложение вместе со всем программным обеспечением. Представь, что вместе с кодом хранятся операционная система, библиотеки,
определённая версия Java и остальные настройки.

Можно сказать, разработчик и правда кладёт в «упаковку» с кодом компьютер, на котором его писал.

Представь: тебе продали рецепт торта, а вместе с ним в коробке — всё, что нужно для готовки. Продукты, скалка, миксер, а ещё — портативная кухня с духовкой и
холодильником.

Docker берёт «упакованные» настройки и создаёт окружение на их основе. Он как будто запускает приложение в отдельной коробочке.

Коробка автономна: всё, что нужно для работы сервиса, уже есть внутри. Это и есть контейнер.

### Как Docker собирает контейнеры

Чтобы Docker собрал контейнер, ему нужен **образ**.

Можно сказать, образ — шаблон для контейнера. Это текстовый файл с инструкциями.

В образе указаны:

- операционная система,
- версия Java,
- код приложения,
- другие настройки виртуального окружения.

Контейнер — это ящик с рецептом, портативной кухней и продуктами для торта. Тогда образ — это заготовки и инструкция, как этот ящик собирать.

Docker берёт образ и на его основе создаёт контейнер. Из одного образа можно создать сколько угодно контейнеров.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_6.png

Каждый контейнер получает уникальный идентификатор — CONTAINER ID. Он выглядит примерно так: `94f92052f55f`. По идентификатору к контейнеру можно обращаться —
например, чтобы остановить его.

### Зачем Docker автоматизатору

**Запускать автотесты**

В контейнерах можно запускать автотесты. Как ты знаешь, для сборки тестировщику нужен Maven. А ещё ты пишешь тесты на Java, поэтому понадобится JDK.

Пригодится контейнер, в котором есть Maven и JDK. Образ для такого контейнера [уже есть](https://hub.docker.com/_/maven).

Автоматизатор или DevOps смонтируют контейнер на его основе.

**Тестировать в разных версиях браузеров**

Если хочешь запускать автотесты в разных версиях одного браузера, придётся установить несколько копий Google Chrome или Mozilla Firefox на один компьютер. Они
могут конфликтовать.

Вместо этого можно создать несколько контейнеров — каждый со своим браузером.

### Docker и Selenium Grid

Чтобы работать в Docker было удобнее, можно развернуть специальный инструмент — **Selenium Grid**.

Selenium Grid — это сервер. Его используют, чтобы запустить тесты сразу в нескольких контейнерах.

Представь: автотесту нужно открыть браузер. Он отправляет запрос: «Мне нужен браузер — такая-то версия».

Selenium Grid принимает запрос и перенаправляет его на свободный сервер — тот, где есть WebDriver и нужный браузер.

Чтобы лучше понять, как это работает, вот аналогия. Представь, что есть команда разработчиков и её лид.

Команде приходит много разных задач. Сперва они попадают к лиду. Лид распределяет задачи между разработчиками: смотрит, кто из них посвободнее, а кто занят.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_7.png

Selenium Grid можно запустить в двух режимах: **Node** и **Hub**.

### **Node**

**Node** — это серверы с запущенным WebDriver и браузером. Их ещё называют «узлами». К ним Selenium Grid и подключает автотесты.

В примере с командой и задачами разработчики — это несколько разных Node.

### **Hub**

**Hub** — это центральный сервер. Он принимает запросы и распределяет нагрузку между Node.

Автотесты подключаются к Hub, а он определяет, к какому Node их направить. Если Node — это разработчики, то Hub — их лид.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_8.png

Node может быть несколько, а вот Hub чаще всего один.

Hub выбирает Node по параметрам, которые ему передают автотесты. Например, нужна определённая версия определённого браузера. Hub ищет контейнер с подходящей
версией.

Есть ещё один инструмент, который делает то же самое.

### Selenoid

Selenoid — такой же инструмент, как Selenium Grid.

Принцип работы — аналогичный. Есть один [Hub](https://hub.docker.com/r/selenoid/hub) и несколько [Node](https://hub.docker.com/r/selenoid/chrome).

Но в Selenium Grid нужно монтировать контейнеры с браузерами самостоятельно. А Selenoid поручает это хабу.

Ещё эти два инструмента поддерживают разные браузеры:

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_54.png

Скорее всего, тебе не придётся настраивать эти инструменты самостоятельно.

## Kubernetes

Kubernetes помогает управлять контейнерами. Чтобы лучше запомнить, зачем нужен этот инструмент, обрати внимание на его название: Kubernetes — от греческого
«управляющий» или «рулевой».

### **Запускать несколько контейнеров одновременно**

Иногда тестировщику достаточно развернуть один контейнер и создать к нему запросы. Например, если сервис маленький: на него заходят от силы десять человек.

Но бывает, нужно развернуть много контейнеров одновременно. Например, тестировщик проверяет банковское приложение. Запросов к нему будет много: провести
транзакцию, отобразить счета, вычислить кешбэк.

Одного контейнера не хватит: он будет долго «думать» или вовсе упадёт под нагрузкой. Можно развернуть несколько серверов вручную, но это долго и неудобно. А ещё
можно ошибиться.

Тут поможет Kubernetes: он развернёт больше контейнеров автоматически.

### **Масштабировать контейнеры**

Часто делают так: выкатывают новую функциональность сначала на часть пользователей, а потом на всех.

Например, добавили кнопку «Загрузить видео» на сайт. Сначала её запускают на тысячу человек: проверяют, что всё работает как нужно. Приложению хватит пары
серверов.

Если всё в порядке, видео загружается, пользователи довольны — функциональность раскатывают на всех. Нужно больше серверов. Тогда Kubernetes увеличивает число
контейнеров.

### **Балансировать нагрузку на контейнеры**

Обычно на разных компьютерах разворачивают несколько одинаковых хостов. Это нужно для страховки: если на каком-то хосте неполадки, копия продолжит работать.

Хосты нужно загружать равномерно, чтобы все они выдерживали нагрузку.

Если произойдёт авария, один из хостов может сломаться. Запросы, которые шли на него, нужно распределить между рабочими контейнерами. Kubernetes делает это сам.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_55.png

Чтобы управлять Kubernetes, нужно вводить команды в консоли. Пока что тебе не понадобится это делать.

В крупных компаниях Kubernetes настраивает команда DevOps: она отвечает за инфраструктуру для тестирования и разработки.

## Jenkins

Jenkins помогает запускать пайплайны — цепочки действий после определённого события.

Как обычно проходит непрерывная интеграция с Jenkins.

**Пуш в репозиторий**. Когда программист заканчивает работать над новой функциональностью, он делает пуш в общий репозиторий.

**Jenkins замечает изменения**. Сервер Jenkins регулярно проверяет, не изменился ли код в общем репозитории.

**Jenkins готовит сборку**. Как только программист запушит изменения, Jenkins начнёт готовить новую сборку. Для этого к нему можно подключить плагин Maven.

**Пока Jenkins готовит сборку, он запускает юнит-тесты**. Если тесты упадут, разработчик получит уведомление — например, по электронной почте.

Можно настраивать списки получателей: например, чтобы уведомление получили менеджер или тестировщик.

Если со сборкой всё в порядке, Jenkins развёртывает встроенный тестовый сервер. Он готовит окружение, в котором запускает автотесты.

**Jenkins рассказывает о результатах тестирования**. Чаще всего уведомление приходит автоматизатору тестирования — прошли автотесты или нет.

Отчёты настраивают так, как удобно компании. Например, можно собрать целую HTML-страницу. А можно просто прислать текст: «Запущено 5 тестов, 3 прошли, а 2 —
нет».

**Jenkins продолжит проверять хранилище исходного кода**. Процесс повторится.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_56.png

## Развернуть Jenkins внутри докер-контейнера

### **Установка Docker Desktop**

Для начала установи Docker Desktop: тогда Docker появится на твоём компьютере.

1. Зайди на [сайт Docker](https://www.docker.com/products/docker-desktop) и скачай файл для своей ОС. Обрати внимание: для MacOS нужны разные файлы в
   зависимости от чипа — Intel или Apple.

2. Открой и установи приложение по шагам.

3. Чтобы проверить, что всё получилось, введи в командной строке:

```bash
docker -v
```

Если всё правильно, появится похожая строка с версией Docker:

```bash
Docker version 20.10.8, build 3967b7d
```

### **Создание docker-compose.yml**

Чтобы развернуть Jenkins, нужно создать файл `docker-compose.yml`.

Файл `docker-compose.yml` помогает развернуть несколько контейнеров так, чтобы они могли общаться друг с другом. Утилита docker-compose использует этот файл,
чтобы скачать нужные образы, подготовить инфраструктуру и развернуть контейнеры.

1. Проверь, что у тебя есть docker-compose. Введи в командной строке:

```bash
docker-compose -v
```

Должна появиться строка с версией docker-compose:

```bash
docker-compose version 1.29.2, build 5becea4c
```

2. Создай файл `docker-compose.yml`. Это можно сделать в текстовом редакторе.

```yaml
version: '3.7' # версия описания docker-compose.yml
services: # описание сервисов, которые развернутся при запуске файла
  jenkins: # развернётся Jenkins
    image: jenkins/jenkins:lts # образ, который скачается для установки Jenkins
    privileged: true
    user: root
    ports: # порты, которые использует сервис
      - 8081:8080 # В контейнере Jenkins развернётся на порте 8080,
        # но на локальной машине этот порт часто занят,
        # поэтому порт 8080 контейнера связывается
        # с портом 8081 на локальной машине.
      # Получится адрес localhost:8081
    container_name: jenkins # имя контейнера: оно может быть любым
```

3. Сохрани файл в любой папке. В командной строке перейди в эту папку и выполни команду:

```bash
docker-compose up
```

Утилита docker-compose сама найдёт нужный YML-файл: если не указать путь к файлу, docker-compose ищет в текущей папке файл с именем `docker-compose.yml`
или `docker-compose.yaml`.

Теперь docker-compose скачает образ Jenkins и развернёт контейнер.

4. Чтобы настроить Jenkins, понадобится пароль. Открой новую вкладку в терминале и выполни команду:

```bash
docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword
```

Ты получишь пароль такого вида:

```bash
06fa6035e6ca477aadd197a2d8912889
```

Сохрани этот пароль: он понадобится на следующем шаге.

### **Настройка Jenkins**

Тебе удалось развернуть Jenkins. Доступ к нему можно получить по адресу http://localhost:8081/. Если доступа нет, открой страницу в режиме инкогнито.

1. Ты увидишь такой экран:

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_10.png

Вставь в поле Administrator password пароль, который тебе удалось получить в консоли, и нажми Continue.

2. На следующем экране выбери Install suggested plugins. Подожди, пока установятся плагины.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_11.png

3. Введи свои данные и кликни Save and Continue. Можно не заполнять эту форму: кликнуть Skip and continue as admin.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_12.png

4. На следующем экране нажми Save and Finish.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_13.png

5. Почти готово! Нажми Start using Jenkins.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_14.png

### **Создание задачи в Jenkins**

У тебя открылся Jenkins.

Чтобы собрать проект, нужно настроить Jenkins: подключить Maven и GitHub.

1. В появившемся окне нажми «Настроить Jenkins».

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_15.png

2. Выбери «Конфигурация глобальных инструментов».

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_16.png

3. Найди кнопку «Добавить Maven». Нажми на неё и заполни поле «Имя» любым значением. Нажми Save.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_17.png

4. Нажми «Создать Item».

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_18.png

5. Введи имя задачи, выбери «Создать задачу со свободной конфигурацией» и нажми OK.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_19.png

6. Найди пункт «Управление исходным кодом». Заполни поле Repository URL: ты можешь вставить ссылку на репозиторий с тестами и файлом `pom.xml` — например, свой
   финальный проект третьего спринта.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_20.png

В блоке Credentials нажми Add → Jenkins. Впиши свой логин и пароль от GitHub и нажми Add.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_21.png

7. Выбери свой логин и пароль в выпадающем списке.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_22.png

8. Прокрути вниз до пункта «Сборка». Нажми «Добавить шаг сборки». В выпадающем списке выбери «Вызвать цели Maven верхнего уровня».

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_23.png

9. В поле «Версия Maven» выбери название из пункта 3. В «Цели» напиши test: тогда при каждой сборке проекта будут запускаться все тесты.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_24.png

Нажми «Сохранить».

10. На следующем экране нажми «Собрать сейчас».

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_25.png

Появится прогресс-бар сборки и тестирования проекта.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_26.png

Когда сборка закончится, должна появиться зелёная галочка: это значит, что всё прошло успешно.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_27.png

Можно кликнуть по ней, чтобы просмотреть детальную информацию о сборке.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_28.png

Например, если нажать на «Вывод консоли», появятся логи. Такие же логи получаются, если собирать и тестировать проект в IDE.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_29.png

## Jenkins и Allure

К Jenkins можно подключить Allure, чтобы получать отчёты и собирать историю тестов.

Для примера возьми такой код с тестами для API сервиса [Mesto](https://qa-mesto.praktikum-services.ru/):

```java
import io.qameta.allure.Description;
import io.qameta.allure.Step;
import io.qameta.allure.junit4.DisplayName;
import io.restassured.RestAssured;
import org.junit.Before;
import org.junit.Test;

import static io.restassured.RestAssured.given;
import static org.hamcrest.Matchers.equalTo;

public class Mesto1Test {

    String bearerToken = "сюда_впиши_свой_токен";

    @Before
    public void setUp() {
        RestAssured.baseURI = "https://qa-mesto.praktikum-services.ru";
    }

    @Test
    @DisplayName("Add a new photo")
    @Description("This test is for adding a new photo to Mesto.")
    public void addNewPhoto() {
        given()
                .header("Content-type", "application/json") // Передаём Content-type в заголовке для указания типа файла
                .auth().oauth2(bearerToken) // Передаём токен для аутентификации
                .body("{\"name\":\"Москва\",\"link\":\"https://code.s3.yandex.net/qa-automation-engineer/java/files/paid-track/sprint1/photoSelenium.jpg\"}") // Формируем тело запроса
                .post("/api/cards") // Делаем POST-запрос
                .then().statusCode(201); // Проверяем код ответа
    }

    @Test
    @DisplayName("Like the first photo")
    @Description("This test is for liking the first photo on Mesto.")
    public void likeTheFirstPhoto() {
        String photoId = getTheFirstPhotoId();

        likePhotoById(photoId);
        deleteLikePhotoById(photoId);
    }

    @Step("Take the first photo from the list")
    private String getTheFirstPhotoId() {
        // Получение списка фотографий и выбор первой из него
        return given()
                .auth().oauth2(bearerToken) // Передаём токен для аутентификации
                .get("/api/cards") // Делаем GET-запрос
                .then().extract().body().path("data[0]._id"); // Получаем ID фотографии из массива данных
    }

    @Step("Like a photo by id")
    private void likePhotoById(String photoId) {
        // Лайк фотографии по photoId
        given()
                .auth().oauth2(bearerToken) // Передаём токен для аутентификации
                .put("/api/cards/{photoId}/likes", photoId) // Делаем PUT-запрос
                .then().assertThat().statusCode(200); // Проверяем, что сервер вернул код 200
    }

    @Step("Delete like from the photo by id")
    private void deleteLikePhotoById(String photoId) {
        // Снять лайк с фотографии по photoId
        given()
                .auth().oauth2(bearerToken) // Передаём токен для аутентификации
                .delete("/api/cards/{photoId}/likes", photoId) // Делаем DELETE-запрос
                .then().assertThat().statusCode(200); // Проверяем, что сервер вернул код 200
    }

}
```

В тестовых методах есть аннотации Allure, которые тебе уже знакомы:

- `@DisplayName` — читаемое имя метода.
- `@Description` — описание теста.
- `@Step` — описание шагов теста.

Добавь этот код на GitHub. Не забудь про `pom.xml`.

Теперь можно собрать тесты и создать отчёт.

### Сборка тестов

1. На главной странице Jenkins нажми «Создать Item», введи имя задачи и выбери «Создать задачу со свободной конфигурацией» — как в прошлом уроке.

2. В разделе «Сборка» нажми «Добавить шаг сборки» и выбери пункт «Вызвать цели Maven верхнего уровня». Выбери версию Maven и введи цель `mvn clean test`: тогда
   тесты соберутся и запустятся.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_30.png

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_31.png

### Отчёт без Allure

Сначала попробуй создать отчёт без Allure.

1. Перейди к разделу «Послесборочные операции», нажми на кнопку «Добавить шаг после сборки» и выбери пункт Publish JUnit test result report.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_32.png

Укажи путь, куда попадут файлы отчёта после сборки проекта. Сохрани задачу.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_33.png

2. Теперь можно запустить сборку и посмотреть, что получилось. Ты уже умеешь это делать: нажми «Собрать сейчас».

3. Дождись, когда завершится сборка, и нажми на неё. Откроется страница, на которой ты можешь посмотреть отчёт.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_34.png

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_35.png

Здесь есть названия тестовых методов, продолжительность тестов и результат, но нет описания и шагов. Чтобы их добавить, нужно интегрировать Allure.

### Отчёт с Allure

Чтобы интегрировать Allure в Jenkins, нужно установить плагин.

1. С главной страницы перейди к пункту «Настроить Jenkins» и выбери пункт «Управление плагинами».

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_36.png

2. Переключись на вкладку «Доступные», найди плагин Allure через поле поиска, выбери его и нажми Install without restart.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_37.png

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_38.png

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_39.png

Напротив плагина появится зелёная галочка:

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_40.png

3. Теперь нужно добавить в Jenkins инструмент Allure Commandline. Тебе уже приходилось устанавливать его на компьютер и строить отчёты командой `allure serve`.
   Чтобы создать отчёт на CI-сервере, тоже нужен этот инструмент.

Нажми «Настроить Jenkins» и выбери пункт «Конфигурация глобальных инструментов».

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_41.png

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_42.png

4. Найди блок Allure Commandline и нажми «Добавить Allure Commandline».

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_43.png

5. Введи имя, выбери версию и сохрани конфигурацию.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_44.png

Готово! Тебе удалось установить и настроить Allure в Jenkins.

Теперь нужно внести правки в задачу.

1. Открой задачу и перейди к настройкам:

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_45.png

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_46.png

2. Перейди к разделу «Послесборочные операции». Удали шаг Publish JUnit test result report.

Нажми «Добавить шаг после сборки» и выбери Allure Report.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_47.png

Укажи путь, куда попадут файлы отчёта после сборки проекта. Плагин найдёт их в этой папке после сборки и создаст отчёт.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_48.png

3. Нажми кнопку «Собрать сейчас». Дождись, пока завершится сборка, и перейди к отчёту.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_49.png

Отчёт будет почти таким же, как и без Jenkins. В разделе Executors появится иконка Jenkins и ссылка на сборку. Обрати внимание: после первого запуска в разделе
Trend ничего не будет.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_50.png

4. Проверь, что получится, если запустить тест с ошибкой. Например, укажи некорректное имя пользователя в первом методе:

```java

@Test
@DisplayName("Check user name")
@Description("This test is for check current user's name.")
public void checkUserName() {
    given()
            .auth().oauth2(bearerToken) // Передаём токен для аутентификации
            .get("/api/users/me") // Делаем GET-запрос
            .then().assertThat().body("data.name", equalTo("Incorrect Name")); // Проверяем, что имя соответствует ожидаемому
}
```

Закоммить изменения и запушь код в репозиторий. Теперь запусти сборку ещё раз и дождись её окончания.

5. Обрати внимание: тест не прошёл, поэтому иконка сборки изменилась. Перейди к отчёту.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_51.png

История запусков появилась в разделе Trend:

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_52.png

И на главной странице задачи в Jenkins:

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_53.png

## Как создать облачный сервер

### Создай аккаунт в Яндекс.Облаке

Зайди на [https://cloud.yandex.ru](https://cloud.yandex.ru/) и залогинься через аккаунт Яндекса.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_57.png

Перейди в консоль Яндекс.Облака: https://console.cloud.yandex.ru/. Нажми «Войти».

Введи любое имя облака и кликни «Создать».

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_58.png

### Создай платёжный аккаунт

Чтобы активировать грант, нажми «Активировать пробный период».

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_59.png

Появится страница, на которой нужно создать платёжный аккаунт.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_60.png

Введи информацию о себе, данные карты и нажми «Активировать».

### Создай виртуальную машину

Чтобы создать облачный сервер, или **виртуальную машину**, зайди [в консоль Яндекс.Облака](https://console.cloud.yandex.ru/).

Тебе понадобится сервис Compute Cloud. Кликни на него в меню слева.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_61.png

Теперь нужно создать виртуальную машину. Кликни на «Создать ВМ».

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_62.png

Введи название проекта на свой выбор.

В качестве публичного образа выбери Ubuntu 20.04. Это дистрибутив Linux.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_63.png

Оставь настройки дисков по умолчанию.

В разделе «Вычислительные ресурсы» выбери:

- Платформа: Intel Cascade Lake.
- vCPU: 2.
- Гарантированная доля vCPU: 5%.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_64.png

В блоке «Доступ» в поле «Логин» введи имя пользователя, по которому будешь заходить на сервер. Оно может быть любым, но должно соответствовать правилам. Их
можно прочитать, если навести курсор на знак вопроса слева от поля.

В поле «SSH-ключ» скопируй свой публичный SSH-ключ. Он понадобится для подключения к серверу.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_65.png

В конце нажми «Создать BM».

Облаку понадобится какое-то время, чтобы создать машину. Примерно через минуту статус изменится на Running — это значит, что машина создана.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_66.png

### Подключение к серверу

Чтобы подключиться к серверу, нужны публичный IP и логин.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_67.png

Зайди в командную строку и введи команду со своим логином и IP:

```bash
ssh логин@публичный IP
```

Если это первое подключение к серверу, ты увидишь фразу:

```bash
The authenticity of host '84.201.130.70 (84.201.130.70)' can't be established.
ECDSA key fingerprint is SHA256:gGz1AULJpNptRRaqLz2FQTDf/IRxSGPA0vvmmXWy/6I.
Are you sure you want to continue connecting (yes/no)?
```

Набери `yes` и нажми Enter. Если твой приватный ключ защищён паролем, нужно ввести пароль от него.

Ты окажешься на удалённом сервере.

Чтобы выйти из сервера, понадобится сочетание клавиш Ctrl+D.

## Как развернуть Jenkins в облаке

### Установка Docker

1. Установить ПО на Linux помогает пакетный менеджер APT. Он загружает пакеты из репозиториев.

   Сначала обнови информацию о доступных пакетах. Для этого нужна команда `update`:

    ```bash
    sudo apt-get update
    ```

2. Установи пакеты, чтобы APT мог соединяться с репозиториями по протоколу HTTPS:

    ```bash
    sudo apt-get install ca-certificates curl gnupg lsb-release
    ```

3. Добавь официальный публичный ключ Docker:

    ```bash
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
    ```

   Если появится надпись `Overwrite? (y/N)`, введи `y`.

4. Выбери репозиторий с образами Docker. Понадобится репозиторий `stable`; есть и другие репозитории — `test` и `nightly`.

    ```bash
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
      $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    ```

5. Когда добавляешь новый репозиторий, нужно снова обновлять информацию о пакетах. Ещё раз выполни команду `update`:

    ```bash
    sudo apt-get update
    ```

6. Установи Docker:

    ```bash
    sudo apt-get install docker-ce docker-ce-cli containerd.io
    ```

7. Проверь, что получилось установить Docker:

    ```bash
    docker -v
    ```

   Должна отобразиться строка вида `Docker version 20.10.11, build dea9396`.

### Установка docker-compose

Следующий шаг — установить docker-compose.

1. Скачай стабильный релиз docker-compose:

    ```bash
    sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
    ```

2. Дай бинарному файлу права на исполнение:

    ```bash
    sudo chmod +x /usr/local/bin/docker-compose
    ```

3. Проверь, что установка прошла успешно:

    ```bash
    docker-compose -v
    ```

   Должна отобразиться строка вида `docker-compose version 1.29.2, build 5becea4c`.

### Установка Jenkins

Чтобы установить Jenkins, создай файл `docker-compose.yml`.

1. Создай файл и открой поток записи в него:

    ```bash
    cat >> docker-compose.yml
    ```

2. Запиши в файл данные:

    ```bash
    version: '3.7' # версия описания docker-compose.yml
    services: # описание сервисов, которые развернутся при запуске файла
      jenkins: # развернётся Jenkins
        image: jenkins/jenkins:lts # образ, который скачается для установки Jenkins
        privileged: true
        user: root
        ports: # порты, которые использует сервис
          - 8081:8080 # В контейнере Jenkins развернётся на порте 8080,
                      # но на локальной машине этот порт часто занят,
                      # поэтому порт 8080 контейнера связывается
                      # с портом 8081 на локальной машине.
                      # Получится адрес localhost:8081
        container_name: jenkins # имя контейнера: оно может быть любым
    ```

3. Перейди на новую строку и нажми Ctrl + C, чтобы прервать поток ввода. Чтобы убедиться, что всё записалось, введи команду:

    ```bash
    cat docker-compose.yml
    ```

4. Осталось запустить Jenkins. Введи команду:

    ```bash
    sudo docker-compose up
    ```

Если всё получилось, можно открыть интерфейс Jenkins на компьютере. Для этого нужно скопировать публичный IP:

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_01_68.png

Введи IP и порт 8081 в адресную строку. Должно получиться примерно так:

```
http://51.250.5.44:8081/
```

Дальше нужно выполнить все те же шаги: настроить Jenkins, установить плагины, создать задачу и запустить сборку.

# Архитектура

## Монолитная архитектура

Современные приложения часто состоят из трёх слоёв:

- **База данных** — здесь хранятся все данные, которые нужны приложению.
- **Бизнес-логика**, или бэкенд, где описана функциональность приложения. Бэкенд обращается к базе, когда нужно что-то сделать с данными.
- **UI** — через этот слой пользователь видит функциональность приложения и может с ним взаимодействовать. У некоторых приложений нет UI.

Приложение с монолитной архитектурой строится так:

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_02_1.png

Слои приложения составляют монолит — единую структуру, в которой все части тесно связаны. Это похоже на стену из кирпичей, которую залили бетоном: нельзя что-то
переделать, не ломая её целиком.

**Пример**. Представь приложение интернет-магазина с функциональностью:

- каталог товаров и акций на них;
- реестр пользователей и их персональных скидок;
- заказ товаров, обработка, оплата и отслеживание.

Если разрабатывать такое приложение с монолитной архитектурой, получится три блока:

- база данных с таблицами для заказов, покупателей и товаров;
- бэкенд для действий с этими сущностями — например, в виде REST API;
- UI, который обращается к бэкенду и отображает функциональность для пользователей.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_02_2.png

Главная особенность монолитной архитектуры — слои не делятся на части. Например, слой бизнес-логики будет отвечать сразу за всю функциональность приложения:
товары, пользователи, заказы и все действия с ними.

Если нужно написать небольшое приложение, которое не будет развиваться и усложняться, монолитная архитектура подойдёт. Ключевые плюсы: скорость разработки,
простота развёртывания и производительность.

Если функциональность будет развиваться, в монолите станет больше связей. С таким проектом сложно работать.

## Микросервисная архитектура

В микросервисной архитектуре приложение делится на сервисы. Это небольшие части, которые отвечают за отдельную функциональность.

У каждого микросервиса — конкретная, небольшая и независимая задача. При этом они не полностью автономны: микросервисы могут передавать друг другу информацию.

Схематично приложение с микросервисной архитектурой выглядит так:

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_02_5.png

Каждый микросервис связан со своей базой данных. В ней хранятся только те данные, которые относятся к его функциональности. К другим базам у микросервиса нет
доступа.

Чаще всего из микросервисов состоит только слой бизнес-логики, а UI остаётся монолитом.

**Пример**. Если разрабатывать приложение интернет-магазина с микросервисной архитектурой, бизнес-логику можно разделить на блоки: заказы, пользователи и
товары. Получится три микросервиса. Вместо одной базы данных будет три: с заказами, пользователями и товарами.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_02_6.png

Микросервисная архитектура позволяет быстро внедрять изменения без потери качества, поэтому по ней построены многие приложения.

### Отличия микросервисной и монолитной архитектуры

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_02_7.png

## Виды межсервисного взаимодействия

### Клиент и сервер

Ты уже знаешь, как взаимодействуют клиент и сервер в веб-приложениях. Клиент запрашивает информацию от сервера.

Сервисы тоже могут обмениваться данными по такой схеме.

**Пример**. В интернет-магазине есть сервис, который обрабатывает заказы. Он подключён к очереди новых заказов. Очередь пополняется, когда покупатель оформляет
заказ.

Сервис не может ничего добавить в очередь. Он берёт заказы, обрабатывает их, а затем обращается к другим сервисам: один формирует платёжные документы, а второй
отправляет письмо о заказе на почту клиента.

В этом примере клиент — это сервис обработки заказов, а серверы — сервисы, которые формируют платёжные документы и отправляют сообщения.

### **Синхронное взаимодействие**

Один сервис отправляет запрос другому и ждёт, когда второй обработает данные. Когда сервис получает ответ, он его обрабатывает.

### **Асинхронное взаимодействие**

При асинхронном взаимодействии между клиентом и сервером есть посредник — **шина данных**, или **брокер сообщений**. Эта система, которая принимает запросы от
сервисов, сохраняет данные, а затем передаёт их другим сервисам.

Клиент отправляет запрос брокеру. Брокер отправляет его серверу или кладёт в очередь.

### Как сервисы обмениваются информацией

Чаще всего сервисы отправляют запросы и получают ответы двумя способами:

- **По протоколу HTTP**. Такой способ тебе уже знаком: у сервиса есть API, к которому могут обращаться другие сервисы.
- **Через шину данных**. Этот способ сложнее: нужно использовать дополнительные инструменты, которые помогают сервисам обмениваться данными. Например, Apache
  Kafka или RabbitMQ.

  Клиент отправляет сообщения брокеру, а брокер — серверу. С одним брокером может работать несколько сервисов. Это возможно, потому что запросы от сервисов
  асинхронны: работа сервисов не блокируется, пока они ждут ответа от сервера.

## Архитектурные паттерны

Многие приложения похожи по внутренней реализации. Они построены по шаблонам — **архитектурным паттернам**. Это типовые решения для задач, которые часто
встречаются в разработке.

Тебе уже
знаком [клиент-серверный шаблон](https://practicum.yandex.ru/learn/qa-automation-engineer-java/courses/e2bf18c2-97c5-43f8-af20-80c52142e6f2/sprints/10893/topics/d247495a-b71f-45c2-9263-1facc7ed4c03/lessons/029f1d48-4608-4582-a034-2ed492d0bd13/).
Есть и другие архитектурные паттерны.

### Многоуровневый шаблон

Многоуровневый шаблон используют, когда программу можно разложить на подзадачи — слои. Каждый слой передаёт информацию следующему, более высокому слою.

Чаще всего встречаются четыре слоя:

1. **Слой представления, или пользовательского интерфейса**. Отрисовывает UI и собирает информацию от пользователя: например, о запросах к приложению.
2. **Слой приложения, или сервиса**. Обрабатывает информацию с уровня представления, передает её на уровень ниже и получает ответ. Этот слой может добавлять,
   изменять и удалять данные из слоя доступа к данным. Иногда слоя приложения нет — тогда всё выполняется на уровне бизнес-логики.
3. **Слой бизнес-логики, или предметной области**. Это классы, которые описывают основные сущности и логику работы программы. Например, в программе для игры в
   шахматы в слое бизнес-логик описаны поле, фигуры и возможные ходы.
4. **Слой доступа к данным, или хранения данных**. Отвечает за взаимодействие с БД или другими источниками данных.

### Каналы и фильтры

Этот шаблон подходит для программ, которые производят и обрабатывают потоки данных. Пример такой программы — компилятор.

По **каналу** передаётся написанный код, а **фильтры** анализируют и компилируют его.

### Model-View-Controller

Паттерн **MVC** (от англ. Model-View-Controller, «модель-представление-контроллер») подходит для программ, которые взаимодействовуют с пользователем.

Программу делят на три части:

1. **Модель**содержит ключевые данные и функциональность.
2. **Представление**показывает информацию пользователю. Представлений может быть несколько.
3. **Контроллер**обрабатывает данные от пользователя.

Например, перед тобой лежит собака. То, что ты видишь, — это **представление** собаки.

Когда ты с ней взаимодействуешь — чешешь за ухом — её нервная система получает информацию об этом.

Нервная система — это **контроллер**. Она передаёт сигналы в мозг — **модель**. Мозг передаёт обратный сигнал, и представление меняется: собака начинает дрыгать
лапой.

В приложении это устроено так:

- **Представление**— пользовательский интерфейс.
- **Контроллер**— обработчик событий, которые запускает пользователь.
- **Модель**— метод, который выполняет операции. Его запускает контроллер.

Обычно модель, представление и контроллер связаны так:

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_02_3.png

Схема не всегда такая. Во многих веб-приложениях модель и вид не взаимодействуют. Модель отдаёт данные контроллеру, а он передаёт их виду. Затем вид меняет
интерфейс.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_02_4.png

**Пример**. Части банковского приложения могут взаимодействовать так:

1. Пользователь взаимодействует с видом — интерфейсом: например, выпускает карту.
2. Запрос уходит на сервер: там контроллер получает запрос и определяет, какой метод API вызвать.
3. Модель выполняет бизнес-операции: регистрирует карту в базе данных, присваивает номер.
4. Модель отправляет данные — например, код 200 и номер карты — обратно в контроллер.
5. Контроллер передаёт эти данные в вид.
6. Пользователь видит в интерфейсе новую карту и её номер.

**Преимущества**. Этот паттерн помогает отделить внутреннее представление информации — бэкенд от представления пользователя — фронтенда.

В MVC компоненты изолированы. Например, можно полностью переписать любой из компонентов, не меняя остальные.

Ещё один плюс — можно использовать код повторно: иногда один и тот же компонент подходит для разных задач. Например, в контроллере приложения есть метод для
сортировки. Через него можно сортировать и новости, и товары.

# Как покрывать тестами разные уровни программы

Как ты знаешь, разные виды тестов выстраиваются в пирамиду тестирования.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/2_intoUItesting_UIpyramid.png

## Сколько проверок каждого вида нужно приложению

Универсального ответа нет: всё зависит от конкретного проекта.

Представь сервис со сложной бизнес-логикой. В коде много методов — а значит, и юнит-тестов.

А может быть наоборот: архитектура простая, а вот API-методов много. Юнит-тестов получится даже меньше, чем интеграционных.

### Расчёт на примере приложения

Посмотри, как распределятся тесты по уровням пирамиды в сервисе [Mesto](https://qa-mesto.praktikum-services.ru/).

Приложение состоит из нескольких слоёв:

- программный код с основными и вспомогательными методами;
- ручки и API-методы, с которыми работает фронтенд;
- UI — с ним работает пользователь через браузер.

Представь, что автотестами покрыты все три уровня. Получается, программный код покрыт юнит-тестами, ручки — интеграционными, а UI — E2E-тестами.

Чтобы считать было проще, представь, что написали только позитивные и негативные тесты. В реальности вариантов больше.

Например, поле ввода электронного адреса можно оставить пустым, ввести некорректный или несуществующий e-mail. Эти три ситуации можно назвать «негативный тест».

### Ручные тесты

Сперва функциональность Mesto проходит через ручных тестировщиков. Они готовят тест-кейсы.

Затем автоматизаторы пишут код, чтобы не проверять функциональность вручную каждый раз.

Если подходить к тестированию так, ручных тестов будет меньше всего, ведь новую функциональность проверяют вручную только один раз. Пока это единственное, что
можно определить точно.

Можно сказать, во время первого релиза ручных тестов столько же, сколько E2E-тестов. Но потом их становится меньше из-за автоматизации.

### E2E-тесты

Следующий уровень пирамиды — E2E-тесты. Нужно проверить такие сценарии:

1. Проверка отображения данных на главной странице без аутентификации.
2. Регистрация.
3. Аутентификация.
4. Проверка отображения данных профиля и списка фотографий.
5. Добавление фотографии.
6. Удаление фотографии.
7. Лайк фотографии.
8. Изменение аватара профиля.
9. Изменение имени профиля.

Для сценариев 1 и 4 негативных проверок не будет: в них проверяют только корректное отображение UI.

Вспомни условие: есть только позитивные и негативные проверки. Получится **16 E2E-тестов**:

- 2 — только позитивные, потому что проверяется UI;
- 7 позитивных и 7 негативных — для остальных сценариев: по две проверки на каждый.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_03_4.png

### Интеграционные тесты

Посмотри на доступные ручки и типы запросов, которые им соответствуют.

Каждый API-метод — отдельный сценарий для тестирования.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_03_5.png

Для методов 3-10 нужны дополнительные негативные тесты. Они проверят, что нельзя обработать запрос без передачи токена.

Получится **28 интеграционных тестов**:

- 10 позитивных;
- 10 негативных;
- 8 негативных, связанных с аутентификацией.

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_03_6.png

### Юнит-тесты

Как ты знаешь, юнит-тесты пишут на конкретные методы.

Сейчас у тебя нет доступа к исходному коду приложения. Не получится посчитать, сколько методов используют.

Это нормально: тестировщик не всегда видит исходный код. Чаще всего юнит-тестами занимается тот, кто эти методы создаёт, — разработчик.

Ты не можешь посчитать, сколько понадобится юнит-тестов. Но можно попробовать оценить на глаз.

Например, посмотри на метод `POST /api/cards`. Он добавляет фотографии на сайт. Скорее всего, его написали так:

- обработка входящего запроса;
- валидация полей — например, для e-mail и пароля;
- заполнение моделей данных, которые соответствуют ручке — например, модель данных фотографии или пользователя;
- обработка ошибок;
- подключение к базе данных;
- добавление значения в базу;
- считывание значения из базы;
- отправка ответа.

Получилось восемь действий. Для каждого нужен отдельный метод. На каждый метод разработчик напишет юнит-тест.

Если знать, сколько методов скрывается за каждой ручкой, можно прикинуть, сколько получится юнит-тестов.

Обрати внимание, что методы обработки входящего запроса, подключения к базе данных, добавления значения в базу, считывания значения из базы и отправки ответа
могут быть общими для нескольких ручек.

Примерное количество методов для всех ручек — 3 * 9 + 5 = **32 метода**:

- по 3 на каждую из 9 ручек;
- 5 общих методов.

## Когда запускают тесты разных уровней

Лучше всего запускать автотесты каждый раз, когда меняется код приложения. Тогда ты узнаешь, всё ли работает как нужно и где появились ошибки.

Такой вариант подойдёт, если автотестов мало: например, приложение небольшое или автоматизация только началась. Чем больше автотестов, тем дольше они
выполняются и тем позже команда узнает о результатах.

Есть несколько способов уменьшить время прогона.

### Ориентироваться на пирамиду тестирования

Пирамида показывает, что быстрых тестов нужно писать больше, чем медленных. Например, юнит-тестов должно быть больше, чем E2E. Тогда приложение будет хорошо
покрыто тестами, а прогон не займёт много времени.

Юнит-тест обычно выполняется несколько миллисекунд или десятков миллисекунд. В больших проектах бывают десятки тысяч юнит-тестов.

E2E-тест может длиться несколько минут. Чтобы ускорить прогон с тем же процентом покрытия, можно частично заменить E2E-тесты юнит-тестами. Например, вместо
десяти E2E-тестов написать один E2E и 10-15 юнит-тестов.

Если проект большой, со временем тестов становится много, даже если разрабатывать их по пирамиде тестирования. Тогда прогон занимает слишком много времени.

### Выполнять автотесты в несколько потоков

Ещё один способ ускорить прогон — выполнять
автотесты [в несколько потоков](https://practicum.yandex.ru/learn/qa-automation-engineer-java/courses/eaa09f96-5559-49b3-9805-4809d5f1ae8b/sprints/15046/topics/6841f513-7116-4718-bea3-47f7bc0b58ab/lessons/fab70d24-9690-4fe5-9083-d8f0e0dabd49/).
Чем больше потоков, тем быстрее пройдут тесты.

Обрати внимание: это правило работает не всегда. Если потоков много, нужна большая мощность серверов. Из-за этого сложнее распределить автотесты по потокам.

Тесты могут выполняться медленнее, если у потоков общие ресурсы: например, база с тестовыми данными. Придётся выбирать, какие проверки когда запускать.

### Когда запускать тесты

**Юнит-тесты** быстрые, поэтому их обычно запускают после каждой сборки приложения. Разработчик может быстро получить отчёт и продолжить писать код. Или
исправлять ошибки.

Для **интеграционных и E2E-тестов** есть разные варианты запуска.

✅ **«По кнопке»**. Тесты запускаются каждый раз, когда кто-то в команде решает, что нужен прогон. Обычно «кнопка» — это команда запуска автотестов в инструменте
CI/CD: например, Jenkins.

⏰ **По расписанию**. Команда решает, сколько раз в день и в какое время запускать тесты. Например, через планировщик заданий сервера CI/CD. Чаще всего тесты
запускают раз в день — ночью. Иногда бывает два прогона: ночью и в середине дня. Когда прогон занимает много времени, автотесты можно запускать не каждый день.
Например, если команда написала много E2E-тестов.

➡️ **Перед релизом**. Некоторые команды запускают все автотесты прямо перед релизом.

Обычно можно совмещать несколько вариантов, Например, автотесты выполняются по расписанию, но их можно запустить и вручную — «по кнопке».

**Другие способы**

Есть и другие способы сократить время прогона. Например, выполнять не все интеграционные и E2E-тесты, а только для той функциональности, которая изменилась.

Ты можешь комбинировать все эти способы. Например, на каждое изменение кода выполнять тест-сьют для этой функциональности, а по ночам делать полный прогон.

## Как оценивать покрытие

### Юнит-тесты

**По условиям.** Условие считается покрытым, если каждая ветвь решения выполнилась.

Например, условие `if (salary > salaryLimit)` покрыто частично: тест проверяет только вариант с зарплатой ниже лимита. Превышение не проверяется.

**По методам.** Метод считается покрытым, если он выполнился при тестировании хотя бы один раз.

Например, метод `calculateSalary` вызывается в тесте. Значит, он покрыт.

Вручную считать покрытие неудобно и долго. Помогают специальные инструменты. Один из самых популярных — **плагин Jacoco**.

### Е2E-тесты

E2E-тесты можно оценивать по требованиям и по тест-кейсам.

**По требованиям**. В идеальном мире происходит так: есть набор требований и набор тестов. С одним или несколькими пунктами требований можно сопоставить хотя бы
один из тестов.

Например, есть требование: «Нельзя зарегистрироваться дважды с одним и тем же электронным адресом». И есть тест со сценарием — регистрируемся один раз,
регистрируемся второй раз с тем же адресом. Требование покрыто.

Процент покрытия вычисляется так:

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_03_1.png

Например, есть 10 требований, а связанных тестов — 5. Процент покрытия — 50%.

**По тест-кейсам**. Можно сопоставить проверки с тест-кейсами и рассчитать покрытие так:

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_03_2.png

Например, для приложения составили 1000 тест-кейсов. Тесты написали на 500 из них. Значит, покрытие 500 / 1000 * 100 % = 50 %.

Такой подход точнее, чем способ с требованиями. В тест-кейсах указывают конкретные параметры, поэтому связать их с тестами проще.

**Тонкости.** Обрати внимание, что нужно следить за актуальностью тест-кейсов — и менять тесты, если что-то переписали.

### Интеграционные

Можно оценивать покрытие по тому, **сколько ручек API протестировано**:

!https://code.s3.yandex.net/qa-automation-engineer/java/schemes/paid-track/sprint4/S4_03_3.png

Например, API состоит из 50 ручек. Интеграционные тесты написали на 25. Значит, тестовое покрытие 25 / 50 * 100 % = 50 %.

**Минусы**. У этого подхода есть минус. Не учитывается, как детально протестированы обязательные параметры ручек. А ещё непонятно, применялись ли необязательные
параметры.

Например, есть ручка GET-запроса — она ищет пользователей. Искать можно по двум параметрам: ID пользователя и его имя.

Эти параметры необязательные. Можно не указывать их — тогда поиск идёт по всему сразу. Ещё можно указать один или сразу оба параметра.

На ручку написали два теста — на запрос без параметров и на запрос с ID. Теста на запрос с именем нет. Формально ручка покрыта, ведь тест на неё есть. Но поиск
по имени не проверили: он может не работать.

Если требования и тест-кейсы написаны для ручек API, можно оценивать покрытие так же, как в случае с E2E тестами.
